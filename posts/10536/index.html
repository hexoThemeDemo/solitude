<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Games101笔记 P11~? | zhywyt's blog</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/solitude/img/pwa/favicon.png"><!-- index.css--><link rel="stylesheet" href="/solitude/css/index.css?v=3.0.15"><!-- inject head--><link rel="canonical" href="https://hexothemedemo.github.io/solitude/posts/10536/index.html"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><!-- aplayer--><!-- swiper--><!-- fancybox ui--><!-- katex--><!-- Open Graph--><meta name="description" content="贝塞尔曲线（Bezier Curve-General Algebraic Formula）三个点的贝塞尔曲线迭代公式： \[b^1_0(t)&amp;#x3D;(1-t)b_0+tb_1 \] \[b_1^1(t)&amp;#x3D;(1-t)b_1+tb_2 \] \[b_0^2(t)&amp;#x3D;(1-t)b"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="zhywyt's blog"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/solitude/img/pwa/favicon.png"><link rel="apple-touch-icon" href="/solitude/img/pwa/favicon.png" sizes="180x180"><script>console.log(' %c Solitude %c ' + '3.0.15' + ' %c https://github.com/everfu/hexo-theme-solitude',
    'background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff',
    'background:#ff9a9a ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff',
    'background:unset ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff')
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)

                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()

                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }

              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })

              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}

                if (name && keyObj[name]) return

                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
            addEventListenerPjax: (ele, event, fn, option = false) => {
              ele.addEventListener(event, fn, option)
              utils.addGlobalFn('pjax', () => {
                  ele.removeEventListener(event, fn, option)
              })
          },
        }
    })()</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    typeof rm === 'object' && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/solitude/',
    algolia: undefined,
    localsearch: undefined,
    runtime: '2023-04-20 00:00:00',
    lazyload: {
        enable: false,
        error: '/img/error_load.avif'
    },
    copyright: false,
    highlight: {"limit":200,"expand":true,"copy":true,"syntax":"highlight.js"},
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"day":" 天","f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可"},
    aside: {
        state: {
            morning: "✨ 早上好，新的一天开始了",
            noon: "🍲 午餐时间",
            afternoon: "🌞 下午好",
            night: "早点休息",
            goodnight: "晚安 😴",
        },
        witty_words: [],
        witty_comment: {
            prefix: '好久不见，',
            back: '欢迎再次回来，',
        },
    },
    covercolor: {
        enable: false
    },
    comment: false,
    lightbox: 'null',
    right_menu: false,
    translate: {"translateDelay":0,"defaultEncoding":2},
    lure: false,
    expire: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: '',
    toc: true,
    comment: false,
    ai_text: false,
    color: false,
}</script></head><body id="body"><!-- universe--><!-- background img--><!-- loading--><!-- console--><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/solitude/archives/"><div class="headline">文章</div><div class="length-num">84</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/solitude/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/solitude/tags/"><div class="headline">标签</div><div class="length-num">5</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude fas fa-circle-half-stroke"></i><span>显示模式</span></span></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="card-tag-cloud"><a href="/solitude/tags/%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/">技术文档<sup>18</sup></a><a href="/solitude/tags/encrypt/">encrypt<sup>1</sup></a><a href="/solitude/tags/%E5%8D%9A%E5%AE%A2/">博客<sup>1</sup></a><a href="/solitude/tags/%E8%AF%97%E4%B8%8E%E6%95%A3%E6%96%87/">诗与散文<sup>1</sup></a><a href="/solitude/tags/%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/">错误解决<sup>5</sup></a></div></div></div></div><!-- keyboard--><!-- righhtside--><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><a id="site-name" href="/solitude/" title="返回博客主页"><span class="title">Solitude</span><i class="solitude fas fa-home"></i></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">Games101笔记 P11~?</a></div></div><div id="menus"></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude fas fa-arrow-up"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude fas fa-bars"></i></a></div></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/solitude/categories/CG/">CG</a></span><div class="tag_share"><div class="post-meta__tag-list"></div></div></div></div><h1 class="post-title">Games101笔记 P11~?</h1><div id="post-meta"><div class="meta-secondline"></div></div></div><div id="post-info-bottom"></div><article class="post-content article-container"><span id="more"></span>

<h2 id="贝塞尔曲线（Bezier-Curve-General-Algebraic-Formula）"><a href="#贝塞尔曲线（Bezier-Curve-General-Algebraic-Formula）" class="headerlink" title="贝塞尔曲线（Bezier Curve-General Algebraic Formula）"></a>贝塞尔曲线（Bezier Curve-General Algebraic Formula）</h2><p><strong>三个点的贝塞尔曲线迭代公式：</strong></p>
<p>\[b^1_0(t)&#x3D;(1-t)b_0+tb_1 \]</p>
<p>\[b_1^1(t)&#x3D;(1-t)b_1+tb_2 \]</p>
<p>\[b_0^2(t)&#x3D;(1-t)b_0^1+tb_!^1 \]</p>
<p><strong>展开得到</strong></p>
<p>\[b^2_0(t)&#x3D;(1-t)^2b_0+(1-t)tb_1+t^2b_2 \]</p>
<p><strong>n个控制点的贝塞尔曲线，每一个时刻曲线上的点的坐标，可以通过二项式展开得到。</strong></p>
<p>\[b^n(t)&#x3D;b_0^n(t)&#x3D;\sum^n_{j&#x3D;0}b_j B^n_j(t) \]</p>
<p><strong>其中\(B^n_j(t)\)就是伯恩斯坦多项式，也就是二项式展开的系数，写作：</strong></p>
<p>\[B_i^n(t)&#x3D;(n,i)^Tt^i(1-t)^{n-1}&#x3D;{C_n^i}t^i(1-t)^{n-i} \]</p>
<p><strong>用语言表述就是，用伯恩斯坦系数给各个控制点加权得到贝塞尔曲线的解。</strong></p>
<p><strong>优美的性质-&gt;1.线性不变：贝塞尔曲线只需要记录控制点的位置，在线性变换下，对控制点进行变换之后重新生成的曲线与直接对曲线进行变换得到的曲线相同。</strong><br><strong>2.凸包性：贝塞尔曲线一定在控制点形成的凸包内。</strong></p>
<h3 id="逐段的贝塞尔曲线"><a href="#逐段的贝塞尔曲线" class="headerlink" title="逐段的贝塞尔曲线"></a>逐段的贝塞尔曲线</h3><p><strong>因为在控制点很多的时候，每一个控制点对曲线的影响很小了，人们更趋向于使用较少的控制点和较多的贝塞尔曲线，来刻画曲线，一般使用四个控制点来处理一段曲线，然后把各段曲线连起来，可以得到不错的效果。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404092403841-28911758_1726324614867.png" alt="image"><br><strong>当一条贝塞尔的曲线的终点和另一条贝塞尔曲线的起点重合时即\(a_n&#x3D;b_0\)，我们叫它\(C_0\)连续。也就是函数连续。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404093138491-201717717_1726324614867.png" alt="image"><br><strong>在\(C_0\)连续的情况下，当一条贝塞尔曲线的终止向量的和另一个贝塞尔曲线的起始向量反向相等时，我们称之为\(C_1\)连续。理解起来就是这条曲线在这点导数连续。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404093530146-333650404_1726324614867.png" alt="image"></p>
<h2 id="Bezier-Surfaces（贝塞尔曲面）"><a href="#Bezier-Surfaces（贝塞尔曲面）" class="headerlink" title="Bezier Surfaces（贝塞尔曲面）"></a>Bezier Surfaces（贝塞尔曲面）</h2><p><strong>用四条贝塞尔曲线的点当作四个控制点，再生成一条贝塞尔曲线，然后遍历之前的贝塞尔曲线，就可以得到贝塞尔曲面。</strong><br><strong>如图，四个贝塞尔曲线上的点形成了新的控制点，然后绘制新的贝塞尔曲线。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404120348910-1769722002_1726324614867.png" alt="image"><br><strong>最后形成贝塞尔曲面：</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404120352291-514470948_1726324614867.png" alt="image"></p>
<h2 id="网格细分-Mesh-Subdivision"><a href="#网格细分-Mesh-Subdivision" class="headerlink" title="网格细分(Mesh Subdivision)"></a>网格细分(Mesh Subdivision)</h2><h3 id="一、Loop-Subdivision（发明人叫Loop和循环没关系）"><a href="#一、Loop-Subdivision（发明人叫Loop和循环没关系）" class="headerlink" title="一、Loop Subdivision（发明人叫Loop和循环没关系）"></a>一、Loop Subdivision（发明人叫Loop和循环没关系）</h3><h4 id="对新顶点"><a href="#对新顶点" class="headerlink" title="对新顶点"></a>对新顶点</h4><p><strong>通过提高三角形的数量来提高模型的质量，把一个三角形分成等大的四块三角形。对于一般情况添加的点来说它会由两三角形所共享，那么这个点就可以由已知的两个三角形所确定。具体就是取加权平均数。</strong></p>
<p>\[E&#x3D;\frac{3}{8}(A++B)+\frac{1}{8}(C+D) \]</p>
<p><strong>其中E点就在AB线段上，C、D就是两个三角形的另外两个顶点。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404194429206-1325605307_1726324633584.png" alt="image"></p>
<h4 id="对旧的顶点"><a href="#对旧的顶点" class="headerlink" title="对旧的顶点"></a>对旧的顶点</h4><p><strong>对于旧的顶点，参考周围的老的顶点，按照“度”（就是一个节点与周围的连线的数量）来进行加权平均，当然旧的点也需要参考自己的坐标。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404194826298-608227788_1726324633584.png" alt="image"><br><strong>其中 u 就是旧节点的度，这里是6。u 就是需要周围点的权值，参考度来生成。除去周围节点的权值，剩下的就是旧节点自己所占的权值了。</strong></p>
<h3 id="二、Catmull-Clark-Subdivision-General-Mesh"><a href="#二、Catmull-Clark-Subdivision-General-Mesh" class="headerlink" title="二、Catmull-Clark Subdivision(General Mesh)"></a>二、Catmull-Clark Subdivision(General Mesh)</h3><p><strong>Loop Subdivision只能处理三角形网格，Catmull则可以细分四边形网格。</strong></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>Non-quad face——非四边形面</strong><br><strong>Extrordinary vertex(degree!&#x3D;4)——奇异点（度不等于4的点）</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404195707955-1284945440_1726324633584.png" alt="image"></p>
<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p><strong>在每一条边上取中电，每一个面上取中点，然后把这些点连起来，增加面密度。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404200142005-592999505_1726324633584.png" alt="image"><br><strong>经过一次操作，把所有的非四边形面变成了奇异点，使得所有的面都是四边形面，又因为非四边形面细分之后得到奇异点，所以在第一次细分之后不会再出现非四边形面。</strong></p>
<h4 id="点的更新"><a href="#点的更新" class="headerlink" title="点的更新"></a>点的更新</h4><h5 id="第一类：四边形中间的点-Face-Point"><a href="#第一类：四边形中间的点-Face-Point" class="headerlink" title="第一类：四边形中间的点(Face Point)"></a>第一类：四边形中间的点(Face Point)</h5><p><strong>直接取顶点的平均即可</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404201130766-1879211902_1726324633584.png" alt="image"></p>
<h5 id="第二类：在边上的点-Edge-Point"><a href="#第二类：在边上的点-Edge-Point" class="headerlink" title="第二类：在边上的点(Edge Point)"></a>第二类：在边上的点(Edge Point)</h5><p><strong>参照构成该边的两个点和附近两个区域的内点进行平均（无视图中的f ）</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404201131296-1917199397_1726324650205.png" alt="image"></p>
<h5 id="第三类：顶点-Vertex-Point"><a href="#第三类：顶点-Vertex-Point" class="headerlink" title="第三类：顶点(Vertex Point)"></a>第三类：顶点(Vertex Point)</h5><p><strong>使用周围的八个点和自身，进行加权平均计算</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404201137194-961881070_1726324650205.png" alt="image"></p>
<h2 id="网格简化-Mesh-Simplification"><a href="#网格简化-Mesh-Simplification" class="headerlink" title="网格简化(Mesh Simplification)"></a>网格简化(Mesh Simplification)</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p><strong>Goal : reduce number of mesh elements while maintaining the overall shape.</strong><br><strong>在保证模型不走样的情况下，减少网格元素。</strong></p>
<h3 id="edge-collapsing-边塌缩"><a href="#edge-collapsing-边塌缩" class="headerlink" title="edge collapsing 边塌缩"></a>edge collapsing 边塌缩</h3><p><strong>边塌缩不是随便删除点就行，需要进行二次度量误差Quadric Error Metrics</strong></p>
<h4 id="Quadric-Error-Of-Edge-Collapse-二次度量误差"><a href="#Quadric-Error-Of-Edge-Collapse-二次度量误差" class="headerlink" title="Quadric Error Of Edge Collapse 二次度量误差"></a>Quadric Error Of Edge Collapse 二次度量误差</h4><p><strong>计算二次度量误差，给每一个边进行二次度量误差检查，给每一个边进行计算，得到一个二次度量误差。从二次度量误差最小的开始。然后每次塌缩最小的一条边，再更新被影响的边。</strong></p>
<h1 id="Shadows-阴影"><a href="#Shadows-阴影" class="headerlink" title="Shadows(阴影)"></a>Shadows(阴影)</h1><h2 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h2><p><strong>只能处理点光源</strong></p>
<h3 id="Key-idea-中心思想"><a href="#Key-idea-中心思想" class="headerlink" title="Key idea 中心思想"></a>Key idea 中心思想</h3><p><strong>如果一个点不在阴影里面，那么这个点可以被光源看到，也可以被相机看到。</strong></p>
<h4 id="Pass1-Render-from-Light-从光源进行光栅化"><a href="#Pass1-Render-from-Light-从光源进行光栅化" class="headerlink" title="Pass1 :Render from Light 从光源进行光栅化"></a>Pass1 :Render from Light 从光源进行光栅化</h4><p><strong>&gt;Depth image from light sourse 从光源进行光栅化，记录点的深度</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404204032301-321657898_1726324650205.png" alt="image"></p>
<h4 id="Pass2A-Render-from-eye"><a href="#Pass2A-Render-from-eye" class="headerlink" title="Pass2A:Render from eye"></a>Pass2A:Render from eye</h4><p><strong>从摄像机进行光栅化</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404204835108-1566699171_1726324650205.png" alt="image"></p>
<h4 id="Pass2B-Project-to-light"><a href="#Pass2B-Project-to-light" class="headerlink" title="Pass2B:Project to light"></a>Pass2B:Project to light</h4><p><strong>把摄像机中的点和这个点对于光源的深度和之前光源光栅化记录的深度进行比较，如果深度一样，说明这个点是可见的，可以被光源和摄像机同时看到。但是如果深度不一样，如图红色的深度是对于光源的深度，蓝色的深度是记录的深度，但深度大于记录的深度时，说明这个点无法被光照到。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404205013148-1468706654_1726324650205.png" alt="image"></p>
<h3 id="Problems-with-shadow-maps"><a href="#Problems-with-shadow-maps" class="headerlink" title="Problems with shadow maps"></a>Problems with shadow maps</h3><p><strong>shadow maps只能做硬阴影，也就是说阴影要么是黑，要么是白，但是现实生活中是软阴影，因为非点光源导致的影子是存在本影和伴影，所以Shadow maps 只能做点光源的阴影，但是不能做立体光源的阴影，也就是软阴影。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404210928547-689965799_1726324662912.png" alt="image"></p>
<h1 id="Ray-Tracing-光线追踪"><a href="#Ray-Tracing-光线追踪" class="headerlink" title="Ray Tracing 光线追踪"></a>Ray Tracing 光线追踪</h1><h2 id="Why-Ray-Tracing"><a href="#Why-Ray-Tracing" class="headerlink" title="Why Ray Tracing?"></a>Why Ray Tracing?</h2><p><strong>Rasterization could’t handle global effects well<br>光栅化不能很好的表现全局的效果</strong><br><strong>And especially when the light bounces more than once<br>光栅化无法很好的处理光线在场景中反射了不止一次的情况</strong><br><strong>(Soft)shadows 不能很好的表示和软阴影</strong><br><strong>Glossy reflection 光泽反射</strong><br><strong>indirect illumination 间接光照</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404212153195-1136159067_1726324662912.png" alt="image"><br><strong>光栅化在处理多次反射的时候会比较麻烦，而且不能保证物理上的正确性。相当于光珊化是一种快速的近似。而光线追踪是非常非常慢的，很真实的图形，一般用于离线，比如动画的渲染。</strong></p>
<h2 id="Basic-Ray-Tracing-Algorithm"><a href="#Basic-Ray-Tracing-Algorithm" class="headerlink" title="Basic Ray-Tracing Algorithm"></a>Basic Ray-Tracing Algorithm</h2><h3 id="Light-Rays-光线"><a href="#Light-Rays-光线" class="headerlink" title="Light Rays 光线"></a>Light Rays 光线</h3><p><strong>Three ideas about light rays</strong><br><strong>1.Light travels in straight lines 光线沿直线传播<br>2.Light rays do not “collide” with each other if they cross 光路互不干扰<br>(though are wrong)<br>3.Light rays travel from the light sources to the eye(光路可逆)</strong></p>
<h3 id="Ray-Casting-光线投射"><a href="#Ray-Casting-光线投射" class="headerlink" title="Ray Casting 光线投射"></a>Ray Casting 光线投射</h3><p><strong>1.Generate an image by casting one ray per pixel通过每像素投射一条光线来生成图像</strong><br><strong>2.Check for shadows by sending aray to the light通过向灯光发送光线来检查阴影</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404213634080-1644512687_1726324662912.png" alt="image"><br><strong>在光线投射中，记录每一根光线碰到的第一个物体closest scene，那么就完美的解决了深度测试的问题，不需要再考虑深度测试。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404214644843-1536928035_1726324662912.png" alt="image"><br><strong>找到一个交点之后，我们考虑这个点会不会被照亮，然后从这个点连一条线到光源，如果路径上没有阻挡，那么就可以说明这点被光照亮了，再利用法线进行着色Shading</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404215058882-1678221168_1726324662912.png" alt="image"><br><strong>这种方法光线还是只反射了一次。</strong></p>
<h3 id="Recursive-Whitted-Style-Ray-Tracing"><a href="#Recursive-Whitted-Style-Ray-Tracing" class="headerlink" title="Recursive(Whitted-Style) Ray Tracing"></a>Recursive(Whitted-Style) Ray Tracing</h3><p><strong>在光线投射的基础上，我们把从像素出发的点在碰到物体之后进行反射和折射。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404215638357-1153355011_1726324741943.jpg" alt="image"><br><strong>最后的着色则由各个点的着色的加权叠加组成，每一个点都需要计算它的shadow ray</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404220203692-491081183_1726324741943.jpg" alt="image"></p>
<h4 id="问题一：Ray-Surface-Intersection（交点）"><a href="#问题一：Ray-Surface-Intersection（交点）" class="headerlink" title="问题一：Ray-Surface Intersection（交点）"></a>问题一：Ray-Surface Intersection（交点）</h4><p><strong>Ray is defined by its origin and a directino vector<br>光线定义为一个起点和一个方向向量</strong><br><strong>光线的方程：</strong></p>
<p>\[Ray: r(t)&#x3D;o+td,0&lt;t&lt; \infty \]</p>
<h5 id="与最简单的图形球的交："><a href="#与最简单的图形球的交：" class="headerlink" title="与最简单的图形球的交："></a>与最简单的图形球的交：</h5><p><strong>球:</strong></p>
<p>\[p:(p-c)^2-R^2&#x3D;0 \]</p>
<p><strong>若相交，那么交点会满足两个方程，我们把光线的方程带入球的方程：</strong></p>
<p>\[(o+td-c)^2-R^2&#x3D;0 \]</p>
<p><strong>然后解时间t，需要满足：</strong><br><strong>1.t是正的<br>2.t不是虚数<br>3.t得是最小的</strong></p>
<h5 id="与隐式表面的交："><a href="#与隐式表面的交：" class="headerlink" title="与隐式表面的交："></a>与隐式表面的交：</h5><p><strong>隐式表面就是L:\(p:f(p)\)表示的一个方程<br>带入得到:</strong></p>
<p>\[f(o+td)&#x3D;0 \]</p>
<p><strong>同样的需要满足，t是正的，t不是虚数</strong><br><strong>目前的求根的方法已经很发达了，所以求根不是问题</strong></p>
<h4 id="怎么计算交点？"><a href="#怎么计算交点？" class="headerlink" title="怎么计算交点？"></a>怎么计算交点？</h4><p><strong>Simple idea:jusr intersect ray with each triangle<br>直接计算每一个三角形与光线是否相交。（很慢，但有效）</strong><br><strong>把问题分解为两个小的问题：<br>1.光线经不经过三角形所在平面<br>2.光线与平面的交点在不在三角形内</strong></p>
<h5 id="三角形所在平面"><a href="#三角形所在平面" class="headerlink" title="三角形所在平面"></a>三角形所在平面</h5><p><strong>点法式<br>平面方程为</strong></p>
<p>\[(P-P’)\cdot N&#x3D;0 \]</p>
<h5 id="求交点"><a href="#求交点" class="headerlink" title="求交点"></a>求交点</h5><p>简单的方法</p>
<p>\[(o+td-P’)\cdot N&#x3D;0 \]</p>
<p>\[t&#x3D;\frac{(P’ -o)\cdot N}{d\cdot N} \]</p>
<p><strong>Check:$0&lt;t&lt;\infty $</strong></p>
<h5 id="交点是不是在三角形内"><a href="#交点是不是在三角形内" class="headerlink" title="交点是不是在三角形内"></a>交点是不是在三角形内</h5><p><strong>交点与顶点构成的向量与边的向量进行叉乘</strong></p>
<p>快速的方法</p>
<h5 id="一步到位-Moller-Trumbore-Algorithm"><a href="#一步到位-Moller-Trumbore-Algorithm" class="headerlink" title="一步到位 Moller Trumbore Algorithm"></a>一步到位 Moller Trumbore Algorithm</h5><p><strong>其中\(\vec O+t\vec D\)就是光线的位置，如果在三角形内，那么一定可以用三角形的重心公式写出来，又这是三维向量，那么就是三个未知数，三个方程，可以直接解线性方程组，就能判断是否相交。甚至可以直接计算行列式来进行在否的判断，而不需要计算点的具体位置。用到克莱默法则</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230404224056612-1622881563_1726324741943.jpg" alt="image"></p>
<h4 id="问题二：加速求交（从三角形数量上）"><a href="#问题二：加速求交（从三角形数量上）" class="headerlink" title="问题二：加速求交（从三角形数量上）"></a>问题二：加速求交（从三角形数量上）</h4><h5 id="Bounding-Volumes-包围盒"><a href="#Bounding-Volumes-包围盒" class="headerlink" title="Bounding Volumes 包围盒"></a>Bounding Volumes 包围盒</h5><p><strong>1.Object is fully contained in the volume.<br>2.If it doesn’t hit the volume, it doesn’t hit the object.<br>3.So test BVol first, then test object if it hits.<br>如果碰不到包围盒，那么肯定碰不到物体，所以首先测试包围盒，如果能碰到包围盒，再测试物体本身。</strong></p>
<p><strong>Axis-Aligned Bounding Box，使用三个对面来唯一确定一个长方体，使用AABB来当作包围盒，与光线进行求交。在二维时候，对于两个对面，我们可以计算出光线进入面和出面的时间（可能为负数），把光线和经过的两个线段求交集，得到的就是光线进入和出去光线的路径。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230415203303290-1777157668_1726324741943.png" alt="image"><br><strong>拓展到三维：只有当光线进入了所有的三个对面后，再出某一个对面。也就是光线进入三个对面的时间都小于离开任意一个对面的时间。也就是最大的进入时间小于最小的离开时间时，说明光线进入了AABB。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230415203557343-697638646_1726324741943.png" alt="image"><br><strong>得到光线与AABB有交点：</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230415204025133-259082333_1726324757389.png" alt="image"><br><strong>为什么使用AABB?计算简单</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230415204203806-874702992_1726324757389.png" alt="image"></p>
<h5 id="Preprocess-Build-Acceleration-Grid"><a href="#Preprocess-Build-Acceleration-Grid" class="headerlink" title="Preprocess - Build Acceleration Grid"></a>Preprocess - Build Acceleration Grid</h5><p><strong>通过画小网格，来细分包围盒。找出可能有物体（边缘）的格子，然后进行光线追踪。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230415205816943-335155476_1726324757389.png" alt="image"><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230415205943409-445354630_1726324757389.png" alt="image"><br><strong>那么对于划分格子也相当有技术，太稀疏和太密集都不太好，一般使用物体的数量乘以27（虽然没什么意义hh）</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230417155520214-1087260474_1726324757389.png" alt="image"></p>
<h5 id="Spatial-Partitions"><a href="#Spatial-Partitions" class="headerlink" title="Spatial Partitions"></a>Spatial Partitions</h5><p><strong>空间划分，因为空旷的地方出现一个小的物体，会导致网格划分非常的低效。使用空间划分来解决这个问题。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230417155855907-1138254026_1726324787053.png" alt="image"><br><strong>第一个是八叉树，进行细分，并且给一个停止细分的规则，比如格子中的物体数量小于某个数。但是八叉树的性质不好，因为细分度和维度呈几何次数上升。2 4 8</strong></p>
<p><strong>第二个是每一次只在格子里沿着某一个轴，进行划分，但是保证划分是交替出现，x\y\z。这么进行不会导致非常高的复杂度，而且保存了二叉树的原理。</strong></p>
<p><strong>第三个是BSP树，不满足AABB</strong></p>
<p><strong>我们主要学习KD-Tree</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230417160746091-1602623499_1726324787053.png" alt="image"><br><strong>进行空间划分，但是对于左边的蓝也需要进行相同弄的操作。会形成一棵二叉树。实际的数据只存储在叶子节点上。进行计算时，首先对最大的包围盒进行计算：</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230417161116330-1146040910_1726324787053.png" alt="image"><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230417161230652-577072786_1726324787053.png" alt="image"><br><strong>发现光线和左边的叶子节点有交点，那么开始计算光线和左边包围盒中的物体进行求交。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230417161438955-543348270_1726324787053.png" alt="image"><br><strong>然后继续搜索。计算所有和光线相交的叶子节点。</strong><br><strong>问题出现了，两个包围盒会同时包括一个物体，那么会产生极大的消耗。使用BVH（Bounding Volume Hierarchy）来解决这个问题。在KD的基础上，进行优化不再划分空间，而是对物体进行划分：把物体分为两堆，然后对物体堆进行包围盒的计算。</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230417162452547-942305627_1726324800127.png" alt="image"><br><strong>但是BVH划分的包围盒存在相交，这也是另一个问题，但是比KD-Tree得到的划分更加的好。BVH的怎么划分就成了重要的问题。</strong><br><strong>BVH的划分：</strong><br><strong>把三角形进行排序，然后取中间的三角形进行划分，可以使得这个树更加的平衡，也就意味着树的深度可以达到最小。算法：</strong><br><strong>给一列n个的数，你要找第i大的数，你可以在o(k)进行处理（快速选择算法）。BVH的递归算法：（伪代码）</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230417163919832-84045790_1726324800127.png" alt="image"><br><strong>KD-Tree与BVH</strong><br><img src="https://raw.githubusercontent.com/zhywyt/cnblogs_pic/master/img/3080748-20230417164037206-1828217995_1726324800127.png" alt="image"></p>
<h2 id="Basic-radiometry-辐射度量学"><a href="#Basic-radiometry-辐射度量学" class="headerlink" title="Basic radiometry(辐射度量学)"></a>Basic radiometry(辐射度量学)</h2></article><div class="post-copyright"><div class="post-copyright__author_group"><div class="post-copyright__author_img"><img class="post-copyright__author_img_front" src="/solitude/img/logo.png"></div><div class="post-copyright__author_name">zhywyt</div><div class="post-copyright__author_desc"></div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/solitude/">zhywyt's blog</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/solitude/posts/15450/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">基于Glut的俄罗斯方块开发</div></div></a></div><div class="next-post pull-right"><a href="/solitude/posts/49493/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">快速读入模板</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="top-group"><div class="sayhi" id="sayhi" onclick="sco.changeWittyWord()"></div></div></div><div class="avatar"><img alt="头像" src="/img/logo.png"></div><div class="description"></div><div class="bottom-group"><span class="left"><div class="name">zhywyt</div><div class="desc">只有迎风，风筝才能飞得更高。</div></span><div class="social-icons is-center"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude fas fa-bars"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%EF%BC%88Bezier-Curve-General-Algebraic-Formula%EF%BC%89"><span class="toc-text">贝塞尔曲线（Bezier Curve-General Algebraic Formula）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E6%AE%B5%E7%9A%84%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF"><span class="toc-text">逐段的贝塞尔曲线</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bezier-Surfaces%EF%BC%88%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E9%9D%A2%EF%BC%89"><span class="toc-text">Bezier Surfaces（贝塞尔曲面）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E7%BB%86%E5%88%86-Mesh-Subdivision"><span class="toc-text">网格细分(Mesh Subdivision)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81Loop-Subdivision%EF%BC%88%E5%8F%91%E6%98%8E%E4%BA%BA%E5%8F%ABLoop%E5%92%8C%E5%BE%AA%E7%8E%AF%E6%B2%A1%E5%85%B3%E7%B3%BB%EF%BC%89"><span class="toc-text">一、Loop Subdivision（发明人叫Loop和循环没关系）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%96%B0%E9%A1%B6%E7%82%B9"><span class="toc-text">对新顶点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%97%A7%E7%9A%84%E9%A1%B6%E7%82%B9"><span class="toc-text">对旧的顶点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Catmull-Clark-Subdivision-General-Mesh"><span class="toc-text">二、Catmull-Clark Subdivision(General Mesh)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C"><span class="toc-text">操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="toc-text">点的更新</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%B1%BB%EF%BC%9A%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%AD%E9%97%B4%E7%9A%84%E7%82%B9-Face-Point"><span class="toc-text">第一类：四边形中间的点(Face Point)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%B1%BB%EF%BC%9A%E5%9C%A8%E8%BE%B9%E4%B8%8A%E7%9A%84%E7%82%B9-Edge-Point"><span class="toc-text">第二类：在边上的点(Edge Point)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%B1%BB%EF%BC%9A%E9%A1%B6%E7%82%B9-Vertex-Point"><span class="toc-text">第三类：顶点(Vertex Point)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E7%AE%80%E5%8C%96-Mesh-Simplification"><span class="toc-text">网格简化(Mesh Simplification)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84"><span class="toc-text">目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#edge-collapsing-%E8%BE%B9%E5%A1%8C%E7%BC%A9"><span class="toc-text">edge collapsing 边塌缩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Quadric-Error-Of-Edge-Collapse-%E4%BA%8C%E6%AC%A1%E5%BA%A6%E9%87%8F%E8%AF%AF%E5%B7%AE"><span class="toc-text">Quadric Error Of Edge Collapse 二次度量误差</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Shadows-%E9%98%B4%E5%BD%B1"><span class="toc-text">Shadows(阴影)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shadow-Mapping"><span class="toc-text">Shadow Mapping</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Key-idea-%E4%B8%AD%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text">Key idea 中心思想</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pass1-Render-from-Light-%E4%BB%8E%E5%85%89%E6%BA%90%E8%BF%9B%E8%A1%8C%E5%85%89%E6%A0%85%E5%8C%96"><span class="toc-text">Pass1 :Render from Light 从光源进行光栅化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pass2A-Render-from-eye"><span class="toc-text">Pass2A:Render from eye</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pass2B-Project-to-light"><span class="toc-text">Pass2B:Project to light</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Problems-with-shadow-maps"><span class="toc-text">Problems with shadow maps</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ray-Tracing-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA"><span class="toc-text">Ray Tracing 光线追踪</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-Ray-Tracing"><span class="toc-text">Why Ray Tracing?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Ray-Tracing-Algorithm"><span class="toc-text">Basic Ray-Tracing Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Light-Rays-%E5%85%89%E7%BA%BF"><span class="toc-text">Light Rays 光线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ray-Casting-%E5%85%89%E7%BA%BF%E6%8A%95%E5%B0%84"><span class="toc-text">Ray Casting 光线投射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recursive-Whitted-Style-Ray-Tracing"><span class="toc-text">Recursive(Whitted-Style) Ray Tracing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9ARay-Surface-Intersection%EF%BC%88%E4%BA%A4%E7%82%B9%EF%BC%89"><span class="toc-text">问题一：Ray-Surface Intersection（交点）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8E%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BE%E5%BD%A2%E7%90%83%E7%9A%84%E4%BA%A4%EF%BC%9A"><span class="toc-text">与最简单的图形球的交：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8E%E9%9A%90%E5%BC%8F%E8%A1%A8%E9%9D%A2%E7%9A%84%E4%BA%A4%EF%BC%9A"><span class="toc-text">与隐式表面的交：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E4%BA%A4%E7%82%B9%EF%BC%9F"><span class="toc-text">怎么计算交点？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E6%89%80%E5%9C%A8%E5%B9%B3%E9%9D%A2"><span class="toc-text">三角形所在平面</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E4%BA%A4%E7%82%B9"><span class="toc-text">求交点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E7%82%B9%E6%98%AF%E4%B8%8D%E6%98%AF%E5%9C%A8%E4%B8%89%E8%A7%92%E5%BD%A2%E5%86%85"><span class="toc-text">交点是不是在三角形内</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E6%AD%A5%E5%88%B0%E4%BD%8D-Moller-Trumbore-Algorithm"><span class="toc-text">一步到位 Moller Trumbore Algorithm</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%9A%E5%8A%A0%E9%80%9F%E6%B1%82%E4%BA%A4%EF%BC%88%E4%BB%8E%E4%B8%89%E8%A7%92%E5%BD%A2%E6%95%B0%E9%87%8F%E4%B8%8A%EF%BC%89"><span class="toc-text">问题二：加速求交（从三角形数量上）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Bounding-Volumes-%E5%8C%85%E5%9B%B4%E7%9B%92"><span class="toc-text">Bounding Volumes 包围盒</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Preprocess-Build-Acceleration-Grid"><span class="toc-text">Preprocess - Build Acceleration Grid</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Spatial-Partitions"><span class="toc-text">Spatial Partitions</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-radiometry-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6"><span class="toc-text">Basic radiometry(辐射度量学)</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude fas fa-map"></i><span>最近发布</span></div><div class="aside-list"><a class="aside-list-item" href="/solitude/posts/10907/" title="在Unity2D中创建角色描边的shader思路"><div class="content"><span class="title" href="/solitude/posts/10907/" title="在Unity2D中创建角色描边的shader思路">在Unity2D中创建角色描边的shader思路</span></div></a><a class="aside-list-item" href="/solitude/posts/5993/" title="Listary——不仅仅是搜索器"><div class="content"><span class="title" href="/solitude/posts/5993/" title="Listary——不仅仅是搜索器">Listary——不仅仅是搜索器</span></div></a><a class="aside-list-item" href="/solitude/posts/51899/" title="我的编辑器"><div class="content"><span class="title" href="/solitude/posts/51899/" title="我的编辑器">我的编辑器</span><span class="categories" href="/solitude/posts/51899/">关于博客</span></div></a><a class="aside-list-item" href="/solitude/posts/0/" title="Untitled"><div class="content"><span class="title" href="/solitude/posts/0/" title="Untitled">Untitled</span></div></a><a class="aside-list-item" href="/solitude/posts/64880/" title="anzhiyu主题搭建记录"><div class="content"><span class="title" href="/solitude/posts/64880/" title="anzhiyu主题搭建记录">anzhiyu主题搭建记录</span><span class="categories" href="/solitude/posts/64880/">闲鱼兼职</span></div></a></div></div></div></div></main><footer id="footer"><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2023 - 2025 By&nbsp;<a class="footer-bar-link" href="/solitude/"><img class="author-avatar" src="/solitude/img/pwa/favicon.png">zhywyt</a></div><div class="beian-group"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://hexo.io/">框架：Hexo</a><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/everfu/hexo-theme-solitude">主题：Solitude</a></div></div></div></div></footer></div><!-- right_menu--><!-- inject body--><div><script src="/solitude/js/utils.js?v=3.0.15"></script><script src="/solitude/js/main.js?v=3.0.15"></script><script src="/solitude/js/third_party/waterfall.min.js?v=3.0.15"></script><script src="https://fastly.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/solitude/js/tw_cn.js?v=3.0.15"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>window.paceOptions = {
  restartOnPushState: false
}

utils.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')
</script><script src="https://fastly.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div class="js-pjax"></div></div><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ["title","#body-wrap","#site-config","meta[name=\"description\"]",".js-pjax","meta[property^=\"og:\"]","#config-diff",".rs_show",".rs_hide"],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- google adsense--><!-- search--><!-- music--></body></html>
        <script>
            const posts = ["posts/10907/","posts/5993/","posts/51899/","posts/0/","posts/64880/","posts/usehttps/","posts/61408/","posts/29b61e029340/","posts/34e784d46b0a/","posts/d7880d8f2f2e/","posts/58283ae7cb2d/","posts/b0c241b3d4cf/","posts/da74aa8e9f3b/","posts/d863527924a0/","posts/247db5136c67/","posts/818482b58c2a/","posts/0e24283556b2/","posts/d8eb45be176b/","posts/8fd9ab7c695f/","posts/4a74e5f5d3d6/","posts/e31df0f4a5f0/","posts/e3e3aee8476b/","posts/d7ea97fbec36/","posts/2024g10/","posts/f29c63b83721/","posts/6e1ed0060e67/","posts/536c11d1caa5/","posts/337e148b3fb3/","posts/2c9570b00976/","posts/d586aba908b5/","posts/5790301d4de2/","posts/96dff400cced/","posts/c8b013b915a1/","posts/bc16e0702e1d/","posts/a5bf365fe3fe/","posts/bd7f49a3fa80/","posts/c6072bab6ff0/","posts/59a4f8f59f45/","posts/823c297f1d7f/","posts/1cc3941f1b85/","posts/54404/","posts/d742d8349fff/","posts/d9709c673656/","posts/5c54bd2bc06c/","posts/df4c31f7ba80/","posts/b4ca7a5fb5b2/","posts/24484/","posts/5953/","posts/5181/","posts/1fd1cabe051b/","posts/49793/","posts/4182/","posts/62236/","posts/7287/","posts/61355/","posts/14027/","posts/53666/","posts/17428/","posts/16515/","posts/11458/","posts/6679/","posts/15892/","posts/3472/","posts/56022/","posts/56214/","posts/6999/","posts/55574/","posts/6886/","posts/6615/","posts/44638/","posts/6295/","posts/45431/","posts/30828/","posts/15450/","posts/10536/","posts/49493/","posts/50901/","posts/27853/","posts/63067/","posts/32280/","posts/51449/","posts/2977/","posts/15959/","posts/47792/"];
            function toRandomPost() {
                const randomPost = posts[Math.floor(Math.random() * posts.length)];
                pjax.loadUrl(GLOBAL_CONFIG.root + randomPost);
            }
        </script>